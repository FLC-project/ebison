<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_22) on Mon Jan 17 15:09:36 CET 2011 -->
<TITLE>
Parser
</TITLE>

<META NAME="date" CONTENT="2011-01-17">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Parser";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../lbj/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?lbj/Parser.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Parser.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
lbj</FONT>
<BR>
Class Parser</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by "><B>lbj.Parser</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Parser</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
This class provides a general purpose parser generator.
 The syntax and semantics of the grammar declaration are described
 in the following sections.

 <h4>Declarations</h4>
 <table cellspacing=0 cellpadding=0 width=100%>
 <tr><td><dt><b>Syntax:</b></tr>
 <tr><td><dd><i>&lt;declarations&gt;</i> ::=<td align=right>(1)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp; <i>&lt;grammar&gt;</i>
     [ <i>&lt;constants declaration&gt;</i> ]
     [ <i>&lt;translation skeme&gt;</i> ]
     [ <i>&lt;examples&gt;</i> ] <td align=right>(1.1)</tr>

 <tr><td><dt><b>Semantics:</b></tr><tr><td colspan=2><dl><dd>
 The parser generator processes a <i>grammar</i> and generates a parser
 (and a lexer) for it.
 <p>
 If a <i>constants declaration</i> is specified, it generates also a
 source file that contains the declaration of constants for the grammar
 symbols to be used in applications.
 <p>
 If a <i>translation skeme</i> is specified, it generates also a
 translation skeme.
 <p>
 If an <i>examples</i> is specified, it parses the example texts and
 reports on the listing the results.
 </table>

 <h4>Grammar</h4>

 <table cellspacing=0 cellpadding=0 width=100%>
 <tr><td><dt><b>Syntax:</b></tr>
 <tr><td><dd><i>&lt;grammar&gt;</i> ::=<td align=right>(1)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;[ <i>&lt;grammar prelude&gt;</i> ]
     { <i>&lt;production&gt;</i> }<sup>+</sup>
     [ <i>&lt;lexis&gt;</i> ] [ <b>END</b> ]<td align=right>(1.1)</tr>
 <tr><td><dd><i>&lt;grammar prelude&gt;</i> ::=<td align=right>(2)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<b>GRAMMAR</b>
     [ "<code>{</code>"<i>&lt;start&gt;</i>
     [ EBNF [ <i>&lt;empty notation&gt;</i> ] ] "<code>}</code>" ]
     <td align=right>(2.1)</tr>
 <tr><td><dd><i>&lt;empty notation&gt;</i> ::=<td align=right>(3)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;nonterminal&gt;
     <td align=right>(3.1)</tr>
   <tr><td><dl><dd><dl><dd>|  <i>&lt;string&gt; <td align=right>(3.2)</tr>
   <tr><td><dl><dd><dl><dd>|  <i>&lt;non-meta&gt; <td align=right>(3.3)</tr>

 <tr><td><dt><b>Semantics:</b></tr><tr><td colspan=2><dl><dd>
 A grammar declaration consists of an optional prelude followed by one
 or more productions, optionally followed by a lexis declaration.
 <p>
 The <i>start</i> defines the starting symbol. If no <i>start</i> is
 present, the starting symbol is the <i>defining occurrence</i> in
 the first <i>production</i>.
 <p>
 If <code>EBNF</code> is specified, multiple <i>production</i>s with
 the same <i>defining occurrence</i> in them are allowed. They are
 considered to be implicitly replaced by one production with one alternative
 for each <i>expression</i> present in them.
 <p>
 If an <i>empty notation</i> is specified, that notation can be used
 to denote the empty string. A grammar containing occurrences of
 <i>empty notation</i>s is equivalent to one in which such occurrences
 have been replaced by <code>""</code>

 <tr><td><dt><b>Static conditions:</b></tr><tr><td colspan=2><dl><dd>
 The <i>start</i> symbol may not be equal to the <i>empty notation</i>.
 It must occur as <i>defining occurrence</i> in a <i>production</i>.
 </table>

 <h4>Productions</h4>

 <table cellspacing=0 cellpadding=0 width=100%>
 <tr><td><dt><b>Syntax:</b></tr>
 <tr><td><dd><i>&lt;production&gt;</i> ::=<td align=right>(1)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;defining occurrence&gt;</i>
     "<code>::=</code>" <i>&lt;expression&gt;</i> [ <code>.</code> ]
     <td align=right>(1.1)</tr>

 <tr><td><dd><i>&lt;defining occurrence&gt;</i> ::=<td align=right>(2)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;nonterminal&gt;</i>
     <td align=right>(2.1)</tr>

 <tr><td><dt><b>Semantics:</b></tr><tr><td colspan=2><dl><dd>
 A <i>production</i> defines a rewriting rule and associates it to
 the <i>defining occurrence</i> in it. The <i>defining occurrence</i> is
 also called "left-hand-side" (LHS) and the <i>expression</i> "right-hand-side"
 (RHS).
 <p>
 Productions can be specified in any order.
 <p>
 Productions can optionally be terminated by a dot (`<code>.</code>') symbol.

 <tr><td><dt><b>Static conditions:</b></tr><tr><td colspan=2><dl><dd>
 The <i>nonterminal</i> defined by a production must be derivable from the
 start symbol and must not be the same as that of the <i>empty notation</i>.
 <p>
 A production must produce at least a terminal string, possibly the
 empty string.
 <p>
 A production which is a <b>token rule</b> must not produce the empty string.
 </table>

 <h4>Expressions</h4>

 <table cellspacing=0 cellpadding=0 width=100%>
 <tr><td><dt><b>Syntax:</b></tr>
 <tr><td><dd><i>&lt;expression&gt;</i> ::=<td align=right>(1)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;[ <i>&lt;alternative&gt;</i>
     { "<code>|</code>" <i>&lt;alternative&gt;</i> }<sup>*</sup> ]
     <td align=right>(1.1)</tr>

 <tr><td><dt><b>Semantics:</b></tr><tr><td colspan=2><dl><dd>
 An <i>expression</i> produces the set of strings which is the union of
 the sets of strings produced by the <i>alternative</i>s which occur in it.
 An <i>expression</i> which is empty produces the empty string.
 <p>
 Operators can occur in <i>expression</i>s. They are left associative
 (e.g. op1 - op2 - op3 is interpreted as {op1 - op2} - op3), and have
 the following precedence (highest first):
 <table><tr><td><i>kind</i></td><td><i>operator</i></td></tr>
 <tr><td>groups</td><td><code>{}</code>, <code>[]</code>,
                        <code>{}*</code>, <code>{}+</code></td></tr>
 <tr><td>case clauses</td><td><code>(i)</code>, <code>(f)</code></td></tr>
 <tr><td>unary operators</td><td><code>!</code>, <code>^</code>, <code>~</code></td></tr>
 <tr><td>concatenation</td><td></td></tr>
 <tr><td>binary operators</td><td><code>-</code>, <code>&</code></td></tr>
 <tr><td>alternation, ranges</td><td><code>|</code>, <code>| .. |</code></td></tr>
 </table>

 <tr><td><dt><b>Static conditions:</b></tr><tr><td colspan=2><dl><dd>
 All <i>alternative</i>s in an <i>expression</i> must be different.
 Two <i>alternative</i>s are equal if they are both or both are not
 <i>range</i>s. In the former case, they are equal if they have the same
 <i>subexpression</i>s in them, in which <i>directive</i>s are not taken into
 account. In the latter case they are the same if the <i>range</i>s have
 the same <i>subexpression</i>s in them.
 N.B. equal alternatives are not allowed because the productions are
 a set of V<sub>N</sub> &times; V<sup>*</sup> (being V<sub>N</sub> the
 nonterminal vocabulary and V the total one) and sets have no duplicates.

 <tr><td><dt><b>Examples:</b></tr><tr><td colspan=2><dl><dd>
 <code>a | b</code> denotes the strings "<code>a</code>" and "<code>b</code>".
 </table>

 <h4>Alternatives</h4>

 <table cellspacing=0 cellpadding=0 width=100%>
 <tr><td><dt><b>Syntax:</b></tr>
 <tr><td><dd><i>&lt;alternative&gt;</i> ::=<td align=right>(1)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;{ <i>&lt;subexpression&gt;</i>
      | <i>&lt;range&gt;</i>} [<i>&lt;priority&gt;</i>]
      <td align=right>(1.1)</tr>

 <tr><td><dd><i>&lt;range&gt;</i> ::=<td align=right>(2)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;subexpression&gt;</i>
      "<code>|</code>" "<code>..</code>" "<code>|</code>"
      <i>&lt;subexpression&gt;</i><td align=right>(2.1)</tr>

 <tr><td><dd><i>&lt;priority&gt;</i> ::=<td align=right>(3)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<code>(prio</code>
      [ <code>:</code> <i>&lt;integer&gt;</i>] <code>)</code>
      <td align=right>(3.1)</tr>

 <tr><td><dt><b>Semantics:</b></tr><tr><td colspan=2><dl><dd>
 An <i>alternative</i> produces the strings of the <i>subexpression</i> or
 the <i>range</i> which occur in it.
 <p>
 A <i>range</i> produces the set of symbols made of all the symbols
 from the one denoted by the first <i>subexpression</i> and the second one
 inclusive.
 <p>
 When a sentence can have several parse trees, ambiguity is solved
 by taking the alternative which has the highest <b>priority</b> when
 different, and the earliest alternative when equal.
 Priority is ineffective when specified on <b>lexicon rule</b>s.

 <tr><td><dt><b>Static conditions:</b></tr><tr><td colspan=2><dl><dd>
 The <i>subexpression</i>s in a <i>range</i> must denote characters, and
 the first one precede or be the same as the second one in the Unicode
 ordering.
 The <i>expression</i> in which a <i>range</i> lies must occur in a
 <b>lexicon rule</b>.
 <p>
 If a <i>range</i> lies in a <i>production</i>, the <i>nonterminal</i>
 defined in it must not occur directly or indirectly in its
 <i>subexpression</i>s.
 <p>
 An alternative must produce at least a terminal string, possibly the
 empty string.
 <p>
 The <b>priority</b> must be greater than zero and lower than 64k.

 <tr><td><dt><b>Static properties:</b></tr><tr><td colspan=2><dl><dd>
 An <i>alternative</i> has a <b>priority</b>, which is the value of the
 <i>integer</i> in the <i>priority</i>, if specified, and zero otherwise.

 <tr><td><dt><b>Examples:</b></tr><tr><td colspan=2><dl><dd>
 <code>a | .. | c</code> &nbsp; denotes the strings "<code>a</code>",
 "<code>b</code>" and "<code>c</code>".
 </table>

 <h4>Subexpressions</h4>

 <table cellspacing=0 cellpadding=0 width=100%>
 <tr><td><dd><i>&lt;subexpression&gt;</i> ::=<td align=right>(1)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;sequence&gt;</i>
     <td align=right>(1.1)</tr>
   <tr><td><dl><dd><dl><dd>|  <i>&lt;subexpression&gt;</i>
     <i>&lt;binary operator&gt;</i> <i>&lt;sequence&gt;</i>
     <td align=right>(1.2)</tr>

 <tr><td><dd><i>&lt;binary operator&gt;</i> ::=<td align=right>(2)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;"<code>-</code>" | "<code>&amp;</code>"
     <td align=right>(2.1)</tr>

 <tr><td><dt><b>Semantics:</b></tr><tr><td colspan=2><dl><dd>
 If a <i>binary operator</i> is specified, a <i>subexpression</i> produces
 the set of strings which is the difference (<code>-</code>) or the
 intersection (<code>&amp;</code>) of the sets of strings produced
 by the <i>subexpression</i> and the <i>sequence</i> which occur in it,
 otherwise it produces the strings of the <i>sequence</i> in it.

 <tr><td><dt><b>Static conditions:</b></tr><tr><td colspan=2><dl><dd>
 The <i>expression</i> in which a <i>binary operator</i> lies must occur in a
 <b>lexicon rule</b>.
 <p>
 If a <i>binary operator</i> lies in a <i>production</i>, the
 <i>nonterminal</i> defined in it must not occur directly or indirectly
 in the <i>subexpression</i> and <i>sequence</i> in it.

 <tr><td><dt><b>Examples:</b></tr><tr><td colspan=2><dl><dd>
 <code>{a | .. | c} - b</code> denotes the strings "<code>a</code>" and
 "<code>c</code>".
 </table>

 <h4>Sequences</h4>

 <table cellspacing=0 cellpadding=0 width=100%>
 <tr><td><dd><i>&lt;sequence&gt;</i> ::=<td align=right>(1)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;term&gt;</i>
     { [<i>&lt;priority&gt;</i>] <i>&lt;term&gt;</i> }<sup>*</sup>
     <td align=right>(1.1)</tr>

 <tr><td><dt><b>Semantics:</b></tr><tr><td colspan=2><dl><dd>
 A <i>sequence</i> produces the string made by the concatenation of the
 strings produced by the <i>term</i>s in it.
 <p>
 When a sentence can have several parse trees due to different matches
 on two adjacent terms, ambiguity is solved by taking the one in which
 the <i>term</i> which has the higher <b>priority</b> generates the longer
 text if priorities are different, and the one in which the earlier
 <i>term</i> generates the longer text when equal.

 <tr><td><dt><b>Static properties:</b></tr><tr><td colspan=2><dl><dd>
 A <i>term</i> has a <b>priority</b>, which is the value of the
 <i>integer</i> in the <i>priority</i> in front of it, if specified, and
 zero otherwise.

 <tr><td><dt><b>Examples:</b></tr><tr><td colspan=2><dl><dd>
 <code>a b c</code> &nbsp; denotes the string "<code>abc</code>".
 </table>

 <h4>Terms</h4>

 <table cellspacing=0 cellpadding=0 width=100%>
 <tr><td><dd><i>&lt;term&gt;</i> ::=<td align=right>(2)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;factor&gt;</i>
     <td align=right>(1.1)</tr>
   <tr><td><dl><dd><dl><dd>|  <i>&lt;unary operator&gt;</i>
     <i>&lt;term&gt;</i><td align=right>(1.2)</tr>

 <tr><td><dd><i>&lt;unary operator&gt;</i> ::=<td align=right>(2)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;"<code>!</code>" |
     "<code>^</code>" | "<code>~</code>"
     <td align=right>(2.1)</tr>

 <tr><td><dt><b>Semantics:</b></tr><tr><td colspan=2><dl><dd>
 If a <i>unary operator</i> is specified, a <i>term</i> produces
 the set of strings which is the complement (<code>!</code>) of the set of
 the strings produced by the <i>term</i> which occurs in it with respect
 to the closure of the <b>alphabet</b>, or the complement(<code>^</code>)
 of the set of characters produced by the <i>term</i> with respect to the
 <b>alphabet</b>, or the set of all strings over the <b>alphabet</b>
 which do not contain the ones denoted by the <i>term</i>, followed by an
 occurrence of them (<code>~</code>).
 Otherwise, it produces the strings of the <i>term</i> in it.

 <tr><td><dt><b>Static conditions:</b></tr><tr><td colspan=2><dl><dd>
 The <i>expression</i> in which a <i>unary operator</i> lies must occur in a
 <b>lexicon rule</b>.
 <p>
 If a <i>unary operator</i> lies in a <i>production</i>, the
 <i>nonterminal</i> defined in it must not occur directly or indirectly
 in its <i>term</i>.
 <p>
 The <i>term</i> in a <i>unary operator</i> which is <code>^</code>
 must denote a set of characters.

 <tr><td><dt><b>Examples:</b></tr><tr><td colspan=2><dl><dd>
 <code>!a</code> denotes all strings which are not "<code>a</code>";
 <code>^a</code> denotes all sysmbols in the <b>alphabet</b> except
 for "<code>a</code>", and <code>~a</code> denotes all strings up to
 and including the first occurrence of "<code>a</code>".
 </table>

 <h4>Factor</h4>

 <table cellspacing=0 cellpadding=0 width=100%>
 <tr><td><dd><i>&lt;factor&gt;</i> ::=<td align=right>(1)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;primary&gt;</i>
      [<i>&lt;case clause&gt;</i> ] <td align=right>(1.1)</tr>

 <tr><td><dd><i>&lt;case clause&gt;</i> ::=<td align=right>(2)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<code>(i)</code> |
      <code>(f)</code><td align=right>(2.1)</tr>

 <tr><td><dt><b>Semantics:</b></tr><tr><td colspan=2><dl><dd>
 If a <i>case clause</i> which is <code>(i)</code> is specified,
 a <i>factor</i> produces the set of strings which is made of the
 strings produced by the <i>primary</i> in it in which each terminal
 character is considered to denote all case variants as defined by the
 simple case-folding of Unicode 3.1. If <code>(f)</code> is specified,
 each characters is considered to denote all case variants as defined by
 full case-folding.
 Otherwise, it produces the strings of the <i>primary</i> in it.
 <p>
 A <i>primary</i> which is a <i>terminal</i>, followed by a
 <i>case clause</i> is equivalent to an <i>expression</i> that generates
 all the case variants of that terminal.
 A <i>primary</i> which is a <i>nonterminal</i>, followed by a
 <i>case clause</i> is equivalent to an occurrence of a nonterminal whose
 rule is the same but has that <i>case clause</i> attached to all
 <i>terminal</i>s which occur directly in it, except on ranges, or
 indirectly through nonterminals, in which case the <i>case clause</i>
 attached to the closest enclosing nonterminal applies.
 A <i>primary</i> which is an <i>autoreference</i>, followed by a
 <i>case clause</i> is equivalent to an occurrence the nonterminal denoted
 by the <i>autoreference</i> followed by that <i>case clause</i>.

 <tr><td><dt><b>Static conditions:</b></tr><tr><td colspan=2><dl><dd>
 The <i>expression</i> in which a <i>case clause</i> lies must occur in a
 <b>lexicon rule</b>.

 <tr><td><dt><b>Examples:</b></tr><tr><td colspan=2><dl><dd>
 <code>a(i)</code> denotes the strings "<code>a</code>" and "<code>A</code>".
 </table>

 <h4>Primary</h4>

 <table cellspacing=0 cellpadding=0 width=100%>
 <tr><td><dd><i>&lt;primary&gt;</i> ::=<td align=right>(1)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;terminal&gt;</i>
     [<i>&lt;store directive&gt;</i>]
     <td align=right>(1.1)</tr>
   <tr><td><dl><dd><dl><dd>|  <i>&lt;nonterminal&gt;</i>
     [<i>&lt;store directive&gt;</i>] <td align=right>(1.2)</tr>
   <tr><td><dl><dd><dl><dd>|  <i>&lt;autoreference&gt;<td align=right>(1.3)</tr>
   <tr><td><dl><dd><dl><dd>|  <i>&lt;group&gt;<td align=right>(1.4)</tr>

 <tr><td><dd><i>&lt;autoreference&gt;</i> ::=<td align=right>(2)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<code>&lt;&gt;</code>
     <td align=right>(2.1)</tr>

 <tr><td><dd><i>&lt;group&gt;</i> ::=<td align=right>(3)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;simple group&gt;</i>
     <td align=right>(3.1)</tr>
   <tr><td><dl><dd><dl><dd>|  <i>&lt;optional group&gt;</i><td align=right>(3.2)</tr>
   <tr><td><dl><dd><dl><dd>|  <i>&lt;Kleene group&gt;</i><td align=right>(3.3)</tr>
   <tr><td><dl><dd><dl><dd>|  <i>&lt;positive Kleene group&gt;</i><td align=right>(3.4)</tr>
   <tr><td><dl><dd><dl><dd>|  <i>&lt;repetitive group&gt;</i><td align=right>(3.5)</tr>

 <tr><td><dd><i>&lt;simple group&gt;</i> ::=<td align=right>(4)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<code>{</code>
     <i>&lt;expression&gt;</i><code>}</code>
     <td align=right>(4.1)</tr>

 <tr><td><dd><i>&lt;optional group&gt;</i> ::=<td align=right>(5)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<code>[</code>
     <i>&lt;expression&gt;</i><code>]</code>
     <td align=right>(5.1)</tr>

 <tr><td><dd><i>&lt;Kleene group&gt;</i> ::=<td align=right>(6)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<code>{</code>
     <i>&lt;expression&gt;</i><code>}<sup>*</sup></code>
     <td align=right>(6.1)</tr>

 <tr><td><dd><i>&lt;positive Kleene group&gt;</i> ::=<td align=right>(7)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<code>{</code>
     <i>&lt;expression&gt;</i><code>}<sup>+</sup></code>
     <td align=right>(7.1)</tr>

 <tr><td><dd><i>&lt;repetitive group&gt;</i> ::=<td align=right>(8)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<code>{</code>
     <i>&lt;expression&gt;</i><code>}</code> <i>&lt;repetition&gt;</i>
     <td align=right>(8.1)</tr>

 <tr><td><dd><i>&lt;repetition&gt;</i> ::=<td align=right>(9)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<code>(</code>
     <i>&lt;lower bound&gt;</i> [<code>:</code> [ <i>&lt;upper bound&gt;</i>]]
     | <code>:</code><i>&lt;upper bound&gt;</i> <code>)</code>
     <td align=right>(9.1)</tr>

 <tr><td><dd><i>&lt;lower bound&gt;</i> ::=<td align=right>(10)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;
     <i>&lt;integer&gt;</i>
     <td align=right>(10.1)</tr>

 <tr><td><dd><i>&lt;upper bound&gt;</i> ::=<td align=right>(11)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;
     <i>&lt;integer&gt;</i>
     <td align=right>(11.1)</tr>

 <tr><td><dd><i>&lt;store directive&gt;</i> ::=<td align=right>(12)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;
     <code>(</code> [<code>-</code>] <code>lex</code>
       [<code>,</code> [<code>-</code>] <code>point</code> ] <code>)</code>
     <td align=right>(12.1)</tr>
   <tr><td><dl><dd><dl><dd>|  <code>(</code>
     [<code>-</code>] <code>point</code>
       [<code>,</code> [<code>-</code>] <code>lex</code> ] <code>)</code>
     <td align=right>(12.2)</tr>

 <tr><td><dt><b>Semantics:</b></tr><tr><td colspan=2><dl><dd>
 A <i>primary</i> produces the string made by the <i>terminal</i> or
 the strings produced by the <i>nonterminal</i>, <i>autoreference</i>,
 or <i>group</i> in it.
 <i>Nonterminal</i>s which denote shorthands produce recursively the elements
 denoted by the shorthand.
 When the <i>expression</i> occurs in a <b>lexicon rule</b>,
 <i>nonterminal</i>s denote the <i>defining occurrence</i>s
 to which they are <b>bound</b>, otherwise they denote the
 <i>replacement defining occurrence</i> to which they are <b>linked</b>.
 Note that a same rule can act both as a <b>lexicon rule</b> and as a
 <b>grammar rule</b>.
 The special symbol <code>&lt;&gt;</code> represents the same nonterminal
 that is being defined by the production in which the <i>expression</i>
 occurs.
 The rules to bind that nonterminal with respect to the grammar or the
 lexicon apply.
 <p>
 A <i>simple group</i> produces the strings produced by the <i>expression</i>
 in it.
 <p>
 An <i>optional group</i> produces the empty string and the strings produced by
 the <i>expression</i> in it. It is not considered as a repetition group in
 the sense that when the <i>expression</i> in it produces the empty string,
 an application of it always occurs, while for a repetition group in such
 a case it does not.
 <p>
 A <i>Kleene group</i> produces the strings made by concatenating any number,
 of times including zero, the strings produced by the <i>expression</i> in it.
 <p>
 A <i>positive Kleene group</i> produces the strings made by concatenating any
 number of times, but at least one, the strings produced by the
 <i>expression</i> in it.
 <p>
 A <i>repetitive group</i> produces the strings made by concatenating any
 number of times, from its <b>lower bound</b> up to its <b>upper bound</b>
 inclusive, the strings produced by the <i>expression</i> in it.
 <p>
 <i>Repetitive group</i>s with an <i>upper bound</i> in them occupy
 a space in parser/lexer tables which is proportional to their
 <b>upper bound</b>.
 <p>
 Note that groups are not equivalent to recursive rules, but to rules
 that virtually contain as many terms as the <i>expression</i> that
 they match. The use of right recursive rule in place of groups leads
 to less efficient parsing, while that of left recursive rules leads
 to more efficient parsing (at the cost of having a different, and
 possibly inappropriate structure of the phrases).
 <p>
 A <i>store directive</i> which contains <code>lex</code> enables the
 storing of the matched lexeme, and one which contains <code>point</code>
 enables the storing of the position in the text. A `<code>-</code>'
 specified in front of them disables storing.
 Storing occurs when:
 <ul>
 <li>a <i>store directive</i> is specified which enables it,
 <li>otherwise (none specified on it), the <i>primary</i> occurs in
   a <i>shorthand definition</i> with attached a <i>store directive</i>
   that enables it, or if none is attached to it, the one on the closest
   shorthand (defining the <i>primary</i> as lexeme) which has a
   <i>store directive</i> attached,
 <li>otherwise (no shorthands specifying it), a <i>store directive</i>
   is specified on the <i>lexis list</i> (possibly on <code>TERMINALS</code>),
 <li>otherwise, the <i>primary</i> is a <b>literal token</b>.
 </ul>

 <tr><td><dt><b>Static conditions:</b></tr><tr><td colspan=2><dl><dd>
 A <i>case clause</i> can be attached only to <i>primary</i>s which
 occur in a <b>lexicon rule</b>.
 <p>
 The <b>upper bound</b> must be greater than or equal to the
 <b>lower bound</b>. Both of them must be greater than zero and
 lower than 64k.
 <p>
 A <i>store directive</i> can be attached only to <i>primary</i>s which
 are <b>lexeme</b>s that occur in a <b>grammar rule</b>.

 <tr><td><dt><b>Static properties:</b></tr><tr><td colspan=2><dl><dd>
 A <i>repetitive group</i> has a <b>lower bound</b>, which is the
 value of the <i>lower bound</i> in it, if specified, and zero otherwise.
 It has an <b>upper bound</b>, which is the value of the <i>upper bound</i>
 in it, if specified; otherwise it is infinite if `<code>:</code>' is
 specified, and else it is the same as the <b>lower bound</b>.
 <p>
 A <i>terminal</i> or <i>nonterminal</i> is a <b>literal token</b> if
 it defines one string only not taking into account <i>case clause</i>s,
 providing that its rule and the ones referred to by it do not contain
 <i>unary operator</i>s or <i>binary operator</i>s.

 <tr><td><dt><b>Examples:</b></tr><tr><td colspan=2><dl><dd>
 <table><tr><td><i>expression</i></td><td><i>meaning</i></td></tr>
 <tr><td><code>[a]</code></td><td><code>empty, a</code></td></tr>
 <tr><td><code>{a}</code></td><td><code>a</code></td></tr>
 <tr><td><code>{a}*</code></td><td><code>empty, a, aa, aaa, ...</code></td></tr>
 <tr><td><code>{a}+</code></td><td><code>a, aa, aaa, ...</code></td></tr>
 </table>
 </table>

 <h4>Lexis</h4>

 <table cellspacing=0 cellpadding=0 width=100%>
 <tr><td><dt><b>Syntax:</b></tr>
 <tr><td><dd><i>&lt;lexis&gt;</i> ::=<td align=right>(1)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<b>LEXIS</b>
     [ <i>&lt;lexis list&gt;</i> ]
     <br>{ <i>&lt;shorthand definition&gt;</i> |
     <i>&lt;replacement definition&gt;</i> }<sup>*</sup>
     [ <i>&lt;alphabet definition&gt;</i> ]
     <td align=right>(1.1)</tr>

 <tr><td><dd><i>&lt;lexis list&gt;</i> ::=<td align=right>(2)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;lexeme&gt;</i>
     { "<code>|</code>" <i>&lt;lexeme&gt;</i> }<sup>*</sup> [ <code>.</code> ]
     <td align=right>(2.1)</tr>

 <tr><td><dd><i>&lt;lexeme&gt;</i> ::=<td align=right>(3)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;terminal&gt;</i>
     [<i>&lt;store directive&gt;</i>]<td align=right>(3.1)</tr>
   <tr><td><dl><dd><dl><dd>|  <i>&lt;nonterminal&gt;</i>
     [<i>&lt;store directive&gt;</i>]<td align=right>(3.2)</tr>
   <tr><td><dl><dd><dl><dd>|  <code>TERMINALS</code><td align=right>(3.3)</tr>

 <tr><td><dd><i>&lt;alphabet definition&gt;</i> ::=<td align=right>(4)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<b>ALPHABET</b> <i>&lt;expression&gt;</i>
     <td align=right>(4.1)</tr>

 <tr><td><dt><b>Semantics:</b></tr><tr><td colspan=2><dl><dd>
 A <i>lexis</i> defines the lexicon.
 <p>
 A <i>lexis list</i> can optionally be terminated by a dot (`<code>.</code>') symbol.
 <p>
 Lexemes are considered as terminal (non-empty) symbols for the grammar proper.
 The grammar is considered to be partitioned in two parts: the lexis
 made by the rules which define the lexemes (together with the rules used
 by them) and the grammar proper, made by the remaining rules. 
 <p>
 <b>TERMINALS</b> denotes the terminal lexemes which are not explicitly
 specified in a <i>lexis list</i> or in the shorthands present in it.
 <p>
 An <i>alphabet definition</i> defines the (terminal) alphabet, which
 is the set of characters produced by the <i>expression</i> in it.
 During the evaluation of that set, the <b>alphabet</b> is set to
 full Unicode.
 <p>
 A <i>store directive</i> specifies the storing of the string or its
 point in the text for all occurrences of the <i>terminal</i> or
 <i>nonterminal</i> (or, when it is a shorthand, of all the elements
 defined by it), unless otherwise specified by <i>store directive</i>s
 appended to occurrences.

 <tr><td><dt><b>Static properties:</b></tr><tr><td colspan=2><dl><dd>
 All the terminals, nonterminals which do not denote shorthands, and
 terminals and nonterminals denoted by shorthands present in the
 <i>lexis list</i> are <b>lexeme</b>s.
 All the terminals derivable from the start symbol, but not from
 <b>lexeme</b>s, are <b>lexeme</b>s too.
 <p>
 All the productions which define <b>lexeme</b>s are <b>token rules</b>s.
 <p>
 All the productions directly or indirectly referred to from the start
 symbol, but not from <b>token rule</b>s, are <b>grammar rule</b>s.
 <p>
 All <b>token rule</b>s and the productions directly or indirectly referred
 to from them are <b>lexicon rule</b>s.
 <p>
 Note that there can be rules which are both grammar and lexicon rules.
 For such rules, a set of rules is impliciltly introduced so as to
 disentangle the grammar by making <b>grammar rule</b>s refer only to
 <b>grammar rule</b>s or <b>token rule</b>s and <b>lexicon rule</b>s refer
 only to <b>lexicon rule</b>s.
 <p>
 An empty <i>lexis list</i>, or no <i>lexis</i>, means that all the
 <i>terminal</i>s are lexemes. To have no lexcon at all (i.e. that terminals
 are the characters), no <i>terminal</i>s which are strings should be used
 (and instead only characters).
 <p>
 The <b>alphabet</b> is the set of characters generated by the
 <i>alphabet definition</i> when present, otherwise it is Unicode.

 <tr><td><dt><b>Static conditions:</b></tr><tr><td colspan=2><dl><dd>
 All lexemes specified in a <i>lexis list</i> or in the shorthands present
 in it, except for those implied by <b>TERMINALS</b>, must be unique.
 <p>
 All <i>terminal</i>s specified in a <i>lexis list</i> must occur
 also in some <i>expression</i> in some production and be <b>lexeme</b>s.
 <p>
 All <b>lexeme</b>s must produce characters that belong to the <b>alphabet</b>.
 <p>
 The <i>expression</i> in an <i>alphabet definition</i> must produce
 a set of characters (i.e. a set of strings of length one).
 </table>

 <h4>Shorthand definitions</h4>

 <table cellspacing=0 cellpadding=0 width=100%>
 <tr><td><dt><b>Syntax:</b></tr>
 <tr><td><dd><i>&lt;shorthand definition&gt;</i> ::=<td align=right>(1)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;defining occurrence&gt;</i>
     <code>==</code>
     <br>{ <i>&lt;nonterminal&gt;</i>
         [<i>&lt;store directive&gt;</i>] |
     <i>&lt;terminal&gt;</i> [<i>&lt;store directive&gt;</i>] }<sup>+</sup>
     [ <code>.</code> ]
     <td align=right>(1.1)</tr>

 <tr><td><dt><b>Semantics:</b></tr><tr><td colspan=2><dl><dd>
 <i>Shorthand definition</i>s define names that stand for lists of lexemes.
 They are made of terminals or nonterminals which denote either other
 shorthands or grammar nonterminals. Occurrences of shorthands in
 <i>expression</i>s (in grammar and replacements rules) have the same
 semantics as groups which contain the lists of alternatives of all the
 lexemes denoted by the shorthands. In <i>expression</i>s in
 <b>lexicon rule</b>s, the elements they denote are bound to their
 origin definition. In the other ones, they are bound to (possily
 redefined) lexemes. Note that when shorthands occur in rules, their
 definitions can contain terminals which do not occur in the grammar
 since they act as groups, like e.g. in:
 <pre>
    &lt;S&gt; ::= b &lt;A&gt;
    LEXIS &lt;A&gt;
    &lt;A&gt; == c
 </pre>
 Formally, a grammar which contains occurrences of shorhands in
 <i>expression</i>s in rules is equivalent to a grammar in which those
 occurrences have been replaced by <i>simple group</i>s containing all
 the elements denoted by the shorthands.
 <p>
 A <i>shorthand definition</i> can optionally be terminated by a dot
 (`<code>.</code>') symbol.
 <p>
 A <i>store directive</i> specifies the storing of the string or its
 point in the text for all occurrences of the <i>terminal</i> or
 <i>nonterminal</i> (or, when it is a shorthand, of all the elements
 defined by it), unless otherwise specified by <i>store directive</i>s
 appended to occurrences.

 <tr><td><dt><b>Static conditions:</b></tr><tr><td colspan=2><dl><dd>
 Elements in shorthand definitions may not be the empty string or the
 empty string notation.
 <p>
 In a shorthand definition all elements must be unique.
 <p>
 A shorthand definition may not contain directly or indirectly occurrences
 of the nonterminal defined by the <i>defining occurrence</i>.
 I.e. shorthand definitions may not be cyclic.
 <p>
 All <i>terminal</i>s specified in a <i>shorthand definition</i> must occur
 also in some <i>expression</i> in some production and be <b>lexeme</b>s.
 </table>

 <h4>Replacement definitions</h4>

 <table cellspacing=0 cellpadding=0 width=100%>
 <tr><td><dt><b>Syntax:</b></tr>
 <tr><td><dd><i>&lt;replacement definition&gt;</i> ::=<td align=right>(1)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;replacement defining occurrence&gt;</i>
     <code>=&gt;</code> <i>&lt;expression&gt;</i>
     [ <code>.</code> ]
     <td align=right>(1.1)</tr>

 <tr><td><dd><i>&lt;replacement defining occurrence&gt;</i> ::=<td align=right>(2)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;lexeme&gt;</i>
     <td align=right>(2.1)</tr>

 <tr><td><dt><b>Semantics:</b></tr><tr><td colspan=2><dl><dd>
 Replacements are a means to define the precise lexical structure
 of lexemes by adding delimiting elements such as spacing and
 comments, or elements that define the spelling, to the defined token
 rules. 
 A <i>replacement definition</i> defines a production for a lexeme which
 replaces in the grammar the original production.
 The resulting grammar is obtained by substituting all occurrences
 of lexemes in the <i>expression</i>s in <b>grammar rule</b>s by occurrences
 of implicitly introduced nonterminals whose definitions are the
 replacement rules. 
 <p>
 A <i>replacement defining occurrence</i> can redefine a terminal.
 <p>
 A <i>replacement definition</i> which has a <i>nonterminal</i>
 in its <i>replacement defining occurrence</i> that is a shorthand
 introduces implicilty one replacement definition for each lexeme
 denoted by the shorthand.
 <p>
 Autoreferences in the <i>expression</i> denote the origin definition
 (formally the production to which the <i>nonterminal</i> in the
 <i>replacement defining occurrence</i> is <b>bound</b>).
 <p>
 Occurrences of <i>nonterminal</i>s and <i>terminal</i>s in the
 <i>expression</i> denote the origin definitions.
 <p>
 A <i>replacement definition</i> can optionally be terminated by a dot (`<code>.</code>') symbol.

 <tr><td><dt><b>Static conditions:</b></tr><tr><td colspan=2><dl><dd>
 The <i>lexeme</i> in a <i>replacement defining occurrence</i>
 may not be the empty string or the empty string notation.
 <p>
 The <i>lexeme</i> in a <i>replacement defining occurrence</i> must
 be a <b>lexeme</b>.
 </table>

 <h4>Constants declaration</h4>

 <table cellspacing=0 cellpadding=0 width=100%>
 <tr><td><dt><b>Syntax:</b></tr>
 <tr><td><dd><i>&lt;constants declaration&gt;</i> ::=<td align=right>(1)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<b>CONSTANTS</b>
     { <i>&lt;constants element&gt;</i> }<sup>*</sup>
     <b>END</b> <td align=right>(1.1)

 <tr><td><dd><i>&lt;constants element&gt;</i> ::=<td align=right>(2)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp; <i>&lt;nonterminal&gt;</i>
       <td align=right>(2.1)</tr>
   <tr><td><dl><dd><dl><dd>|  <code>n</code> "<code>(</code>"
       <i>&lt;symbol&gt;</i> "<code>)</code>" <td align=right>(2.2)</tr>
   <tr><td><dl><dd><dl><dd>|  <code>t</code> "<code>(</code>"
       <i>&lt;symbol&gt;</i> {, <i>&lt;symbol&gt;</i> }<sup>*</sup>
       "<code>)</code>" <td align=right>(2.3)</tr>
   <tr><td><dl><dd><dl><dd>|  <i>&lt;string&gt;</i>
       <td align=right>(2.4)</tr>

 <tr><td><dd><i>&lt;symbol&gt;</i> ::=<td align=right>(3)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;
         <i>&lt;nonterminal&gt;</i> <td align=right>(3.1)</tr>
   <tr><td><dl><dd><dl><dd>|  <i>&lt;terminal&gt;<td align=right>(3.2)</tr>

 <tr><td><dt><b>Semantics:</b></tr><tr><td colspan=2><dl><dd>
 A <i>constants declarations</i> instructs the parser generator to
 produce a file containing the declarations of the specified constants.
 Each <i>constants element</i> is transferred to the file as follows:
 <ul>
 <li><i>nonterminal</i>: it is replaced by the number of the nonterminal
 <li><code>n(</code><i>symbol</i><code>)</code>: it is replaced
   by the number of the nonterminal or the terminal in it
 <li><code>t(</code><i>symbol</i><code>,...)</code>: it is replaced
   by the number of the token set of the tokens in it
 <li><i>string</i>: it is copied by replacing occurrences of "\n"
   with the platform specific line separator.
 </ul>
 Note that <i>terminal</i>s must not be either written as <i>string</i>s
 or separated by a following comma with a space.

 <tr><td><dt><b>Static conditions:</b></tr><tr><td colspan=2><dl><dd>
 A <i>nonterminal</i> and a <i>terminal</i> must denote syntax elements
 defined in the <i>grammar</i>.
 <p>
 A list of tokens must denote a token set recognized by the lexer.
 <p>
 <tr><td><dt><b>Examples:</b></tr><tr><td colspan=2><dl><dd>
 <pre>
   CONSTANTS
       "interface MySyntax {\n"
       "    static final int IDENT = " <identifier> ";\n"
       "    static final int AA_ID = " {"aa" <identifier>} ";\n"
       ...
       "}"
   END
 </pre>
 Note that generating an interface containing the constants allows to have
 a source file which can be compiled directly. Without an interface
 there would be a need to include them in the application.
 </table>

 <h4>Translation skeme</h4>

 <table cellspacing=0 cellpadding=0 width=100%>
 <tr><td><dt><b>Syntax:</b></tr>
 <tr><td><dd><i>&lt;translation skeme&gt;</i> ::=<td align=right>(1)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp; <b>TRANSLATIONS</b>
     { <i>&lt;translation&gt;</i> }<sup>*</sup>
     <b>END</b> <td align=right>(1.1)</tr>

 <tr><td><dd><i>&lt;translation&gt;</i> ::=<td align=right>(2)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;nonterminal&gt;</i>
     "<code>=</code>" <i>&lt;pattern&gt;</i>
     { "<code>|</code>" <i>&lt;pattern&gt;</i> }<sup>*</sup>
     [ <code>.</code> ] <td align=right>(2.1)</tr>

 <tr><td><dd><i>&lt;pattern&gt;</i> ::=<td align=right>(3)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;
     { <i>&lt;string&gt;</i> |
     <i>&lt;nonterminal&gt;</i> [<i>&lt;integer&gt;</i>]
     | <i>&lt;rewriting&gt;</i> }<sup>+</sup>
     <td align=right>(3.1)</tr>

 <tr><td><dd><i>&lt;rewriting&gt;</i> ::=<td align=right>(4)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;
     {<code>s</code> | <code>t</code>}
     "<code>(</code>" { <i>&lt;symbol&gt;</i>
         ["<code>,</code>" <i>&lt;integer&gt;</i>]
         | <i>&lt;integer&gt;</i> } "<code>)</code>"
     <td align=right>(4.1)</tr>

 <tr><td><dt><b>Semantics:</b></tr><tr><td colspan=2><dl><dd>
 Translations are a means to specify the strings to be generated
 when an occurrence of the rule to which they are associated occurs
 in the (source) text.
 They associate to the rules of a <i>nonterminal</i> the patterns
 specified in them in the same order.
 <p>
 Patterns are made of:
 <p>
 <ul>
 <li>(constant) <i>strings</i>s, which translate to themselves.
 <li><i>nonterminal</i>s, which denote the string matched by them,
   If more than one occurrence of a same nonterminal in a rule exists,
   the desired one can be selected by specifying its <i>integer</i>
   ordinal numbers (from zero upwards).
 <li><i>rewriting</i>s, which apply to the specified occurrence
   (denoted by the <i>integer</i>, or the first if not present)
   of the specified <i>symbol</i> in the rule. The `<code>s</code>' rewriting
   is replaced by the string matched, the `<code>t</code>' one is replaced
   by the translation of the string matched.
 </ul>
 <p>
 For the definitions of <i>nonterminal</i>, <i>terminal</i>, <i>string</i>,
 <i>integer</i> and <i>symbol</i>, refer to the class Parser.

 <tr><td><dt><b>Static conditions:</b></tr><tr><td colspan=2><dl><dd>
 The <i>nonterminal</i> in a <i>translation</i> must denote a
 <b>grammar rule</b>.
 <p>
 A <i>nonterminal</i> in a <i>pattern</i> must denote a nonterminal
 which occurs in the associated rule, and an <i>integer</i> must denote
 an occurrence which exists.
 </table>

 <h4>Vocabulary</h4>

 <table cellspacing=0 cellpadding=0 width=100%>
 <tr><td><dt><b>Syntax:</b></tr>
 <tr><td><dd><i>&lt;nonterminal&gt;</i> ::=<td align=right>(1)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<code>&lt;</code>
     { <i>&lt;<u>non-close</u> character&gt;</i> |
         <i>&lt;string&gt;</i> }<sup>+</sup>
     <code>&gt;</code>
     <td align=right>(1.1)</tr>

 <tr><td><dd><i>&lt;terminal&gt;</i> ::=<td align=right>(2)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;string&gt;</i>
     <td align=right>(2.1)</tr>
   <tr><td><dl><dd><dl><dd>|  <i>&lt;non-meta symbol&gt;<td align=right>(2.2)</tr>

 <tr><td><dd><i>&lt;string&gt;</i> ::=<td align=right>(3)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<code>"</code>
     { <i>&lt;<u>non-quote</u> character&gt;</i> |
     <i>&lt;escape&gt;</i> }<sup>*</sup> <code>"</code>
     <td align=right>(3.1)</tr>

 <tr><td><dd><i>&lt;escape&gt;</i> ::=<td align=right>(4)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<code>\n</code> |
     <code>\n</code> | <code>\t</code> | <code>\b</code> |
     <code>\r</code> | <code>\f</code> | <code>\\</code> |
     <code>\'</code> | <code>\"</code> | <br>
     <code>\</code><i>&lt;octal&gt;</i><i>&lt;octal&gt;</i><i>&lt;octal&gt;</i> | <br>
     { <code>\</code><code>u</code> | <code>\</code><code>U</code> }
         <i>&lt;hex&gt;</i><i>&lt;hex&gt;</i><i>&lt;hex&gt;</i><i>&lt;hex&gt;</i>
     <td align=right>(4.1)</tr>

 <tr><td><dd><i>&lt;octal&gt;</i> ::=<td align=right>(5)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<code>0</code> |
     <code>1</code> | <code>2</code> | <code>3</code> |
     <code>4</code> | <code>5</code> | <code>6</code> |
     <code>7</code><td align=right>(5.1)</tr>

 <tr><td><dd><i>&lt;hex&gt;</i> ::=<td align=right>(6)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;octal&gt;</i> |
     <code>8</code> | <code>9</code> | <code>a</code> | .. |
     <code>f</code> | <code>A</code> | .. | <code>F</code>
     <td align=right>(6.1)</tr>

 <tr><td><dd><i>&lt;non-meta symbol&gt;</i> ::=<td align=right>(7)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;{
     <i>&lt;<u>non-meta</u> character&gt;</i> }<sup>+</sup>
     <td align=right>(7.1)</tr>

 <tr><td><dd><i>&lt;integer&gt;</i> ::=<td align=right>(8)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;{ <code>0</code> |
     <code>1</code> | <code>2</code> | <code>3</code> |
     <code>4</code> | <code>5</code> | <code>6</code> |
     <code>7</code> | <code>8</code> | <code>9</code>
     }<sup>+</sup><td align=right>(8.1)</tr>

 <tr><td><dt><b>Semantics:</b></tr><tr><td colspan=2><dl><dd>
 Grammars are represented using the Unicode character set.
 The alphabet is represented by the nonterminal <i>&lt;character&gt;</i>
 from which any Unicode character can be derived as terminal production.
 The lexical elements of a grammar declaration are:
 <p>
 <ul>
 <li><i>nonterminal</i>s
 <li><i>terminal</i>s
 <li><i>integer</i>s
 <li>reserved symbols.
 <li>special character combinations.
 </ul>
 <p>
 Lexical elements are terminated by the first character which cannot
 belong to them, possibly by spacing and comments.
 <>
 <i>Nonterminal</i>s represent syntactic categories. <i>Terminal</i>s
 represent strings over the terminal alphabet. The empty string is
 denoted by <code>""</code> or by the nonterminal or terminal symbol
 defined as <i>empty notation</i> in the <i>grammar prelude</i>.
 <p>
 A <i><u>non-close</u> character</i> is a character other than the
 closing angular bracket (`<code>&gt;</code>'), the double quote
 (`<code>&quot;</code>') and the format effectors (BS, VT, HT, CR and LF).
 <p>
 Lowercase and uppercase letters are different.
 <p>
 In a <i>nonterminal</i> the characters enclosed in parentheses are
 ignored. E.g. <code>&lt;(integer)expression&gt;</code> is the same as
 <code>&lt;expression&gt;</code>.
 When closing angular brackets, format effectors, double quotes,
 or sequences of characters enclosed in parentheses need be part of
 a nonterminal, they must be represented as <i>string</i>s. The
 notation of <i>string</i>s can be used to introduce any sequence of
 characters in a <i>nonterminal</i>.
 <p>
 A <i><u>non-quote</u> character</i> is a character other than the
 double quote (`<code>"</code>').
 <p>
 <i>Terminal</i>s are <i>string</i>s or <i>non-meta symbol</i>s
 which are not reserved symbols or special character combinations.
 <p>
 A <i><u>non-meta</u> character</i> is an ASCII character from <code>!</code>
 to <code>~</code> other than the double quote(`<code>"</code>').

 <tr><td><dt><b>Static conditions:</b></tr><tr><td colspan=2><dl><dd>
 A <i>non-meta symbol</i> may not be one of the special character 
 combinations:
 <code>{</code>     &nbsp; <code>[</code>        &nbsp; <code>]</code>    &nbsp;
 <code>|</code>     &nbsp; <code>=></code>       &nbsp; <code>==</code>   &nbsp;
 <code>={</code>    &nbsp; <code>::=</code>      &nbsp; <code>..</code>   &nbsp;
 <code>.</code>     &nbsp; <code>}*</code>       &nbsp; <code>}+</code>   &nbsp;
 <code>}</code>     &nbsp; <code>&lt;&gt;</code> &nbsp; <code>&lt;</code> &nbsp;
 <code>&gt;</code>  &nbsp; <code>!</code>        &nbsp; <code>^</code>    &nbsp;
 <code>-</code>     &nbsp; <code>~</code>        &nbsp; <code>(</code>    &nbsp;
 <code>&amp;</code> &nbsp;
 and <code>)</code> &nbsp;.
 <p>
 A <i>non-meta symbol</i> may not be one of the reserved symbols:
 <b>ALPHABET</b>, <b>END</b>, <b>GRAMMAR</b>, <b>LEXIS</b>, and
 <b>TERMINALS</b>.
 </table>

 <h4>Spaces and comments</h4>

 <table cellspacing=0 cellpadding=0 width=100%>
 <tr><td><dt><b>Syntax:</b></tr>
 <tr><td><dd><i>&lt;comment&gt;</i> ::=<td align=right>(1)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<i>&lt;bracketed comment&gt;</i>
     <td align=right>(1.1)</tr>
   <tr><td><dl><dd><dl><dd>|  <i>&lt;line-end comment&gt;</i>
     <td align=right>(1.2)</tr>
   <tr><td><dl><dd><dl><dd>|  { <i>&lt;space&gt;</i> | <i>&lt;tab&gt;</i> |
     <i>&lt;end-of-line&gt;</i> }<sup>*</sup>
     <td align=right>(1.3)</tr>

 <tr><td><dd><i>&lt;bracketed comment&gt;</i> ::=<td align=right>(2)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<code>/</code><code>*</code>
     { <i>&lt;character&gt;</i> | <i>&lt;end-of-line&gt;</i> }<sup>*</sup>
     <code>*</code><code>/</code>
     <td align=right>(2.1)</tr>

 <tr><td><dd><i>&lt;line-end comment&gt;</i> ::=<td align=right>(3)</tr>
   <tr><td><dl><dd><dl><dd>&nbsp;&nbsp;<code>//</code>
     { <i>&lt;character&gt;</i> }<sup>*</sup>
     <i>&lt;end-of-line&gt;</i>
     <td align=right>(3.1)</tr>

 <tr><td><dt><b>Semantics:</b></tr><tr><td colspan=2><dl><dd>
 Comments have no relevance for the semantics. They document a grammar
 declaration.
 They can be inserted before and after any lexical element.
 <p>
 The string produced as a sequence of <i>character</i>s in a
 <i>bracketed comment</i> may not contain the sequence
 <code>*</code><code>/</code>.
 <p>
 The string produced as a sequence of <i>character</i>s in a
 <i>line-end comment</i> may not contain the <i>end-of-line</i>
 <p>
 The element <i>&lt;space&gt;</i> denotes the space character;
 <i>&lt;tab&gt;</i> the horizontal tabulation character, and
 <i>&lt;end-of-line&gt;</i> the end of a line, be it a character or
 a system-dependent representation of the separation between lines.
 </table>

 <h4>Visibility and name binding</h4>
 A <i>nonterminal</i> is <b>visible</b> when:
 <ul>
 <li>there is a <i>defining occurrence</i> with that <i>nonterminal</i>
   in the grammar declaration. 
   The <i>nonterminal</i> is said to be <b>bound</b> to it.
 <li>there is a (possibly implicit) <i>replacement defining occurrence</i>
   with that <i>nonterminal</i> in the grammar declaration. 
   The <i>nonterminal</i> is said to be <b>linked</b> to it.
 </ul>
 <p>
 A <i>terminal</i> is <b>linked</b> to a (possibly implicit)
 <i>replacement defining occurrence</i> with that <i>terminal</i> in it
 when such a definition exists.
 <p>
 The following conditions must be satisfied:
 <ul>
 <li>a <i>nonterminal</i> must be <b>bound</b> to exactly one
   <i>defining occurrence</i>.
 <li>a <i>nonterminal</i> can be <b>bound</b> to exactly one
   <i>replacement defining occurrence</i>.
 <li>a <i>terminal</i> can be <b>bound</b> to exactly one
   <i>replacement defining occurrence</i>.
 </ul>
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../lbj/Parser.html#Parser()">Parser</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lbj/Parser.html#main(java.lang.String[])">main</A></B>(java.lang.String[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Run the parser.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../lbj/Parser.html#settrc(java.lang.String)">settrc</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the trace flags which are specified in the argument.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Parser()"><!-- --></A><H3>
Parser</H3>
<PRE>
public <B>Parser</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="settrc(java.lang.String)"><!-- --></A><H3>
settrc</H3>
<PRE>
public static void <B>settrc</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD>Set the trace flags which are specified in the argument.
 The string must contain only lowercase letters.
 Upon return <code>trc</code> is the powerset of flags augmented
 with the ones specified.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - string of flags</DL>
</DD>
</DL>
<HR>

<A NAME="main(java.lang.String[])"><!-- --></A><H3>
main</H3>
<PRE>
public static void <B>main</B>(java.lang.String[]&nbsp;args)</PRE>
<DL>
<DD>Run the parser. It performs the analysis of the command, it creates
 the output files, it calls the parsing of the input and it creates
 the listing.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../lbj/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?lbj/Parser.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Parser.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
